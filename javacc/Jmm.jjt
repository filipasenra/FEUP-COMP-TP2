options
{
    LOOKAHEAD=1;
    MULTI=true;
    STATIC=false;
}

// When in javacc folder
// jjtree Jmm.jjt
// javacc Jmm.jj
// When in root folder (comp2020-3a)
// gradle build
// or
// gradle test

PARSER_BEGIN(Jmm)
public class Jmm {

    private static final int MAX_ERRORS = 10;
    private int nErrors = 0;

    public static void main(String args[]) throws ParseException {
        if(args.length != 1){
            System.err.println("Usage: java Jmm <filename>");
            return;
            }
        
        try {
            Jmm myParser = new Jmm(new java.io.FileInputStream(args[0]));

            SimpleNode root = myParser.ParseExpression(); // returns reference to root node 
            if(myParser.nErrors > 0 ){
                throw new RuntimeException("Has errors");
            }
            root.dump(""); // prints the tree on the screen
            System.out.println("Finished Parsing");

        } 
        catch (java.io.FileNotFoundException e) {
            System.out.println("file " + args[0] + " not found.");
            return;
        }        
    }

    private void errorHandling(ParseException e, int kindToConsume, int kindNotToConsume) {

        nErrors++;

        if(nErrors > MAX_ERRORS){

            throw new RuntimeException("Reached maximum number of errors (" + MAX_ERRORS + ")!");
            
        }

        error_skipto(e, kindToConsume, kindNotToConsume);

    }

    private void error_skipto(ParseException e, int kindToConsume, int kindNotToConsume) {
    
        Token t;
        Token t1;

        do {
            t1 = getToken(1);
            if(t1.kind ==  kindNotToConsume)
                {
                    System.out.println("Syntactical error: Missing \")\" at line " + t1.beginLine + " and column " + t1.beginColumn + ".");
                    return;
                }

            t = getNextToken();
        
        } while (!(t.kind == kindToConsume || t.kind == EOF));

        System.out.println("Syntactical error: " + customErrorMessage(e));  // print the error message


    }

    private String customErrorMessage(ParseException e) {
        StringBuffer expected = new StringBuffer();

        for (int i = 0; i < e.expectedTokenSequences.length; i++) {

            for (int j = 0; j < e.expectedTokenSequences[i].length; j++) {
                expected.append(e.tokenImage[e.expectedTokenSequences[i][j]]).append(' ');
            }

            expected.append("\n\t");
        }

        return "Encountered \"" + e.currentToken.next + "\" at line " + e.currentToken.beginLine + " and column " + e.currentToken.beginColumn + " was expecting \n\t" + expected.toString();  // print the error message
    }
}

PARSER_END(Jmm)


/* Caracters to be skiped */
SKIP:
{
    " " | "\r" | "\t" | "\n" 
    | <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")> |         /* Inline comments */
    <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">    /* Block comments */
}

/*Reserved Words*/
TOKEN :
{
    <IMPORT: "import" (~[";"])* ";" > //Temporary: Change when professors give all the rules erase
    | <CLASS: "class" >
    | <EXTENDS: "extends">
    | <PUBLIC: "public">
    | <RETURN: "return">
    | <STATIC: "static">
    | <VOID: "void">
    | <MAIN: "main">
    | <STRING: "String">
    | <INT: "int">
    | <BOOLEAN: "boolean">
    | <IF: "if">
    | <ELSE: "else">
    | <WHILE: "while">
    | <LENGTH: "length">
    | <TRUE_: "true">
    | <FALSE_: "false">
    | <THIS: "this">
    | <NEW: "new">
}

/*Identifier and IntegerLiteral*/
TOKEN:
{
    /*IntegerLiteral*/
     < INTEGER_LITERAL : <DECIMAL> | <HEXADECIMAL> | <BINARY> | <OCTAL> > 
   | < #DECIMAL: (["0"-"9"])+ > 
   | < #HEXADECIMAL: ("0x" | "0X")(["0"-"9", "A"-"F", "a"-"f"])+ > 
   | < #BINARY: ("0b" | "0B")(["0", "1"])+ > 
   | < #OCTAL: "0"(["0"-"7"])* > 

   /*Identifier*/
   | < IDENTIFIER : <LETTER> (<LETTER> | <DIGIT>)* > 
   | < #LETTER : ["$", "_", "a"-"z", "A"-"Z"] > 
   | < #DIGIT : ["0"-"9"] >
    
}

/* Delimitaters*/
TOKEN : {
    < SEMICOLON: ";">
    | < COLON: ",">
    | < LEFT_BRACE: "{">
    | < RIGHT_BRACE: "}">
    | < LEFT_BRACKET: "[">
    | < RIGHT_BRACKET: "]">
    | < LEFT_PARENTESIS: "(">
    | < RIGHT_PARENTESIS: ")">
    | < DOT: ".">
}

/*Operators*/
TOKEN : {
    <SUM: "+">
    | <SUB: "-">
    | <MUL: "*">
    | <DIV: "/">
    | <LESS_THAN: "<">
    | <AND: "&&"> 
    | <NEGATION: "!">
    | <ASSIGN: "=">
}

SimpleNode ParseExpression(): {}
{
    ClassDeclaration() <EOF> {return jjtThis;} //Java code inside brackets

}

void ClassDeclaration(): {Token className; Token extendsClass;} {

    (<IMPORT>)*
    <CLASS> className = <IDENTIFIER> (<EXTENDS> extendsClass = <IDENTIFIER>  {jjtThis.ext = extendsClass.image;})?
    <LEFT_BRACE> 
        ( VarDeclaration() )*
        ( MethodDeclaration() )*
    <RIGHT_BRACE>
    { jjtThis.name = className.image; }

}

void VarDeclaration() : {Token t;} {
    Type() t = <IDENTIFIER> <SEMICOLON> {jjtThis.name = t.image;}
}

void Type() : {Token t;} {
   (t = <INT> (<LEFT_BRACKET> <RIGHT_BRACKET> {jjtThis.isArray = true;})?)
   | t = <BOOLEAN> | t = <IDENTIFIER> | t = <STRING>
   { jjtThis.type = t.image; }
}

void MethodDeclaration() #void : {Token t;} {
    <PUBLIC> 
    ((<STATIC> <VOID> <MAIN> 
    <LEFT_PARENTESIS> 
        <STRING> <LEFT_BRACKET> <RIGHT_BRACKET> <IDENTIFIER>
    <RIGHT_PARENTESIS>
    <LEFT_BRACE> 
        (LOOKAHEAD(2) VarDeclaration())* 
        (Statement())*
    <RIGHT_BRACE>) #MainDeclaration
    |
    (Type() t = <IDENTIFIER>
    <LEFT_PARENTESIS> 
        (Type() <IDENTIFIER> (<COLON> Type() <IDENTIFIER>)*)?
    <RIGHT_PARENTESIS>
    <LEFT_BRACE> 
        (LOOKAHEAD(2) VarDeclaration())* 
        (Statement())*
        <RETURN>
        Expression()
        <SEMICOLON>
    <RIGHT_BRACE> ) {jjtThis.name = t.image;} #MethodDeclaration )

}


void Statement() #void : {} {

    (<LEFT_BRACE> (Statement())* <RIGHT_BRACE> ) #ComplexStatement
    | If()
    | While()
    | (LOOKAHEAD(2) Equality() | (Expression() <SEMICOLON>) ) #SimpleStatement
}

void If() : {} {
    <IF> 
        <LEFT_PARENTESIS> Expression() <RIGHT_PARENTESIS>
        Statement()
    <ELSE>
        Statement()
}

void While() : {} {
    <WHILE> 
        try {
            <LEFT_PARENTESIS> Expression() <RIGHT_PARENTESIS>

        } catch (ParseException e) {
            
            errorHandling(e, RIGHT_PARENTESIS, LEFT_BRACE);
        }
        
        Statement()
}

void Equality() : {Token t;} {
    t = <IDENTIFIER> 
        (<LEFT_BRACKET> Expression() <RIGHT_BRACKET> {jjtThis.isArray = true;} )?
        <ASSIGN> Expression() <SEMICOLON> {jjtThis.name = t.image;}
}

void Expression() : {} {

    AND()

}

 void AND() #void : {} {
     LessThan() (LOOKAHEAD(2) <AND> LessThan() #AND(2))*
 }

 void LessThan() #void : {} {
     Sum() (LOOKAHEAD(2) <LESS_THAN> Sum() #LESSTHAN(2))*
 }

 void Sum() #void : {} {
     Mul() (LOOKAHEAD(2) (<SUM> | <SUB>) Mul() #SUM(2))*
 }

 void Mul() #void : {} {
     Literal() (LOOKAHEAD(2) (<MUL> | <DIV>) Literal() #MUL(2))*
 } 

void Literal() #void : {Token t;} {
   DotExpression() | 
   ( t= <INTEGER_LITERAL> | t = <TRUE_> | t = <FALSE_>) {jjtThis.val = t.image;} #Literal
}

void DotExpression() #void : {} {
     BracketExpression() (LOOKAHEAD(2) <DOT> (<IDENTIFIER> | <LENGTH>)
            (<LEFT_PARENTESIS> 
                (Expression() (<COLON> Expression())*)?
            <RIGHT_PARENTESIS>)?
         )* #DotExpression
 } 

 void BracketExpression() #void : {} {
     FinalExpression() (LOOKAHEAD(2) <LEFT_BRACKET> Expression() <RIGHT_BRACKET>)*
 } 

void FinalExpression() #void : {Token t;} {

    New()
    | ( <NEGATION> Expression()) #Negation
    | ( <LEFT_PARENTESIS> Expression() <RIGHT_PARENTESIS>)
    | (t = <IDENTIFIER> | t = <THIS>) {jjtThis.val = t.image;} #Literal
}

void New() #void : {} {
     <NEW> ( NewIntObject() | NewObject() )
}

void NewIntObject() : {} {
    <INT> <LEFT_BRACKET> Expression() <RIGHT_BRACKET>
}

void NewObject() : {Token t;} {
    t = <IDENTIFIER> <LEFT_PARENTESIS> <RIGHT_PARENTESIS> {jjtThis.val = t.image;}
}